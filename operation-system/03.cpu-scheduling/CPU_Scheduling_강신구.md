# 11. CPU 스케줄링

## 1 ) CPU 스케줄링 개요

1. CPU 스케줄링
    1. 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
    2. CPU를 선착순으로 배분하는 것은 효율적인 방식이 아니다.
        - 프로세스마다 우선순위가 존재하기 때문이다.
    3. 프로세스 특징
        1. 대부분의 프로세스들은 CPU와 입출력 장치를 모두 사용
        2. 즉, 실행 상태와 대기 상태를 반복하며 실행된다.
        3. 프로세스 종류마다 입출력 장치를 이용하는 시간과 CPU를 이용하는 시간에 차이가 있다.
            - 입출력 집중 프로세스
                - 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스
                - 실행 상태 < 대기 상태
            - CPU 집중 프로세스
                - 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스
                - 실행 상태 > 대기 상태
        4. CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구한 경우
            - 입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력 장치를 작동시키고, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 효율적이다.
    4. 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.
2. 스케줄링 큐
    1. 개요
        1. PCB에 우선순위가 있다고는 하지만, 모든 프로레스의 PCB를 확인하는 것은 비효율적이다.
        2. 또한 CPU 뿐만 아니라 메모리, 입출력 장치, 보조 기억 장치를 사용하길 원하는 프로세스도 다양하게 있기 때문에 매우 번거롭고 시간도 오래 걸린다.
        3. 그래서 운영체제는 큐(스케줄링 큐)를 만들어 프로세스들을 삽입하여 줄을 세운다.
            - 메모리 큐
            - CPU 큐
            - 특정 입출력 장치 큐
            - …
        4. 프로세스들로 하여금 줄을 세우면서 동시에 높은 우선순위부터 실행한다.
    2. 종류
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/9f4cebdb-ec4f-4928-b4f3-68870cfaafd9/Untitled.png)
        
        1. 준비 큐
            - CPU를 이용하고 싶은 프로세스들이 서는 줄
        2. 대기 큐
            - 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
        3. 입출력이 완료되어 인터럽트가 발생
        4. 대기 큐에서 해당 PCB를 찾아 준비 상태로 변경
        5. 대기 큐에서 삭제
        6. 준비 큐에 삽입
3. 선점형과 비선점형 스케줄링
    1. 선점형 스케줄링
        1. 운영체제가 프로세스로부터 자원을 강제로 빼앗아 더 급한 다른 프로세스에게 할당하는 방식
        2. 즉, 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
        3. 장점
            - 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다.
        4. 단점
            - 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
    2. 비선점형 스케줄링
        1. 하나의 프로세스가 자원을 사용하고 있다면, 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식
        2. 장점
            - 문맥 교환 횟수가 적어 오버헤드 발생이 적다.
        3. 단점
            - 모든 프로세스가 골고루 자원을 사용할 수 없다.
            

## 2 ) CPU 스케줄링 알고리즘

1. 선입 선처리 스케줄링(First Come First Served Scheduling, FCFS 스케줄링)
    1. 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 방식
    2. 프로세스들이 기다리는 시간이 매우 길어질 수 있다.
        - 호위 효과(Conoy Effect)
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/dcf8985e-a7ed-4619-96e2-350bf5a1f0ee/Untitled.png)
        
2. 최단 작업 우선 스케줄링(Shortest Job First Scheduling, SJF 스케줄링)
    1. 호위 효과를 방지하기 위해 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 방식
    2. 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수도 있다.
        - 선점형 최단 작업 우선 스케줄링
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/ca335c8c-79bb-4dd1-b8cd-f8bf04cdd7af/Untitled.png)
        
3. 라운드 로빈 스케줄링(Round Robin Scheduling)
    1. 선입 선처리 스케줄링(1)에 타임 슬라이스라는 개념이 더해진 방식
    2. 타임 슬라이스
        - 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
    3. 즉, 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
    4. 방식
        1. 삽입된 순서대로 CPU를 이용하되 정해진 시간만큼 CPU를 이용
        2. 만약 정해진 시간 안에 프로세스를 완료하지 못했다면 다시 큐의 맨 뒤에 삽입
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/b38e23ec-6875-4ac6-a9a9-c5847530a096/Untitled.png)
        
        - 타임 슬라이스 크기가 매우 중요하다.
            - 타임 슬라이스가 지나치게 큰 경우
                - 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있다.
            - 타임 슬라이스가 지나치게 작은 경우
                - 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 치중하게 된다.
4. 최소 잔여 시간 우선 스케줄링(Shortest Remaining Time, SRT 스케줄링)
    1. 최단 작업 우선 스케줄링(2)과 라운드 로빈 스케줄링(3)을 합친 방식
        1. 최단 작업 우선 스케줄링
            - 작업 시간이 짧은 프로세스부터 처리하는 알고리즘
        2. 라운드 로빈
            - 정해진 타임 슬라이스만큼 돌아가며 CPU를 사용하는 알고리즘
    2. 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스를 선택하는 방식
5. 우선순위 스케줄링(Priority Scheduling)
    1. 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 방식
        - 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있다.
    2. 기아(starvation) 현상
        - 우선순위가 낮은 프로세스의 실행이 우선순위가 높은 프로세스에 의해 계속 뒤로 밀리는 현상
    3. 에이징(aging)
        - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
6. 다단계 큐 스케줄링
    1. 우선순위별로 준비 큐를 여러 개 사용하는 방식
        - 우선순위 스케줄링(5)의 발전된 형태
    2. 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 큐가 비어 있다면 다음 우선순위에 있는 큐의 프로세스를 처리한다.
    3. 또한, 큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/d84dbd8e-a99e-4883-bdf5-42e2504b619a/Untitled.png)
        
7. 다단계 피드백 큐 스케줄링
    1. 다단계 큐 스케줄링의 발전된 형태
        1. 다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없다.
        2. 따라서 기아 현상이 발생할 수 있다.
        3. 이를 보완한 것이 다단계 피드백 큐 스케줄링이다.
            - 프로세스들이 큐 사이를 이동할 수 있다.
    2. 방식
        1. 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입하고, 일정 시간동안 실행된다.
        2. 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐로 이동시킨다.
            - 또 해당 큐에서 끝나지 않는다면 다음 우선순위 큐로 게속 이동시킨다.
            - 끝나지 않는다면 우선순위를 계속 낮춘다.
    3. CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝나게 된다.
    4. 또한, 낮은 우선순위 큐에서 너무 오래 기다리고 잇는 프로세스가 있다면 에이징 기업을 적용하여 점자 우선순위가 높은 큐로 이동시킴으로써 기아 현상을 예방할 수 있다.
