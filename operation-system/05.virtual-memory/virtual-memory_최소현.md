![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/7e9dbf07-7662-43f2-ad43-0d57ce10191a/Untitled.png)

## 연속 메모리 할당 방식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/c4bdd134-f775-4ced-8689-b4f68a49b635/Untitled.png)

### First-Fit (최초 적합)

메모리 내의 빈 공간을 순서대로 검사하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식

- 장점
    
    빠른 할당 가능
    

### Best-Fit (최적 적합)

빈 공간을 모두 검색해본 후, 프로세스가 적재할 수 있는 공간 중 가장 작은 공간에 프로세스를 배치

### Worst-Fit (최악 적합)

빈 공간을 모두 검색해본 후, 적재할 수 있는 공간 중 가장 큰 공간에 프로세스를 배치

- 왜사용? 지선생
    - **다양한 옵션 제공**: 최악 적합 방법은 다른 배치 방법들과 비교할 수 있는 기준을 제공하며, 이를 통해 다른 방법들의 효율성을 평가할 수 있습니다. 다양한 배치 방법을 연구함으로써 어떤 방법이 특정 상황에서 더 효율적인지 분석할 수 있습니다.
    - **특정 상황에서 유용**: 최악 적합 방법이 항상 비효율적인 것은 아닙니다. 특정 상황에서는 최악 적합 방법이 더 나은 성능을 발휘할 수 있습니다. 예를 들어, 메모리 조각화가 심각하게 발생하는 시스템에서는 큰 블록을 먼저 사용함으로써 작은 블록들을 더 잘 활용할 수 있는 기회를 제공할 수 있습니다.
        - 예시
            
            ### 상황 설명:
            
            1. **시스템 상태**: 메모리 조각화가 심각하게 발생하여 메모리에 여러 개의 작은 빈 공간들이 산재해 있는 상황입니다. 예를 들어, 다음과 같이 메모리가 분할되어 있다고 가정해봅시다:
                - 10KB
                - 20KB
                - 5KB
                - 15KB
                - 30KB
            2. **프로세스 요구**: 다음과 같은 크기의 프로세스들이 순차적으로 메모리 할당을 요청합니다:
                - 프로세스 A: 12KB
                - 프로세스 B: 7KB
                - 프로세스 C: 5KB
                - 프로세스 D: 10KB
            
            ### 최악 적합 할당 방식 적용:
            
            최악 적합 방식은 가장 큰 빈 블록에 프로세스를 할당합니다.
            
            1. **프로세스 A (12KB)**:
                - 가장 큰 블록은 30KB입니다.
                - A는 30KB 블록에 할당됩니다.
                - 남은 블록: 18KB (30KB - 12KB)
            2. **프로세스 B (7KB)**:
                - 남은 블록들: 10KB, 20KB, 5KB, 15KB, 18KB
                - 가장 큰 블록은 20KB입니다.
                - B는 20KB 블록에 할당됩니다.
                - 남은 블록: 13KB (20KB - 7KB)
            3. **프로세스 C (5KB)**:
                - 남은 블록들: 10KB, 5KB, 15KB, 18KB, 13KB
                - 가장 큰 블록은 18KB입니다.
                - C는 18KB 블록에 할당됩니다.
                - 남은 블록: 13KB (18KB - 5KB)
            4. **프로세스 D (10KB)**:
                - 남은 블록들: 10KB, 5KB, 15KB, 13KB, 13KB
                - 가장 큰 블록은 15KB입니다.
                - D는 15KB 블록에 할당됩니다.
                - 남은 블록: 5KB (15KB - 10KB)
            
            ### 결과 분석:
            
            최악 적합 방식 적용 후 남은 블록들:
            
            - 10KB
            - 5KB
            - 13KB
            - 13KB
            - 5KB
            
            이 상황에서는 각 프로세스가 큰 블록에 할당됨으로써 큰 블록들이 잘게 쪼개졌습니다. 하지만 최악 적합을 사용하지 않고 다른 방법을 사용했다면 작은 블록들이 더 작은 블록들로 쪼개지면서 더 심각한 조각화가 발생할 수 있었습니다. 이렇게 함으로써 남은 블록들이 균일해지고, 앞으로 더 작은 프로세스들이 할당될 때 더 쉽게 할당될 수 있는 환경이 조성되었습니다.
            

### 단점

- 외부 단편화 발생

프로그램들이 실행되고 종료되는 것을 반복하면서 메모리 사이에 빈공간이 생겨, 큰 프로세스를 적재하기 어려운 상황

—> 메모리 낭비

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/6cf686bc-b527-490f-99ee-2d1157c381de/Untitled.png)

## 페이징을 통한 메모리 관리 방식

- 페이지
    
    프로세스의 논리 주소 공간
    
- 프레임
    
    페이지와 동일한 크기의 일정한 단위로 자른 물리 주소 공간
    

### 페이징

페이지를 프레임에 할당하는 가상 메모리 관리 기법으로, 프로세스 전체가 아닌 페이지 단위로 스왑아웃 (페이지아웃), 스왑인 (페이지인)을 함.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/2510f8ef-9eda-45cb-b58a-47e65f1886e5/Untitled.png)

—> 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만 메모리에 적재

### 페이지 테이블

물리 주소가 불연속적일때 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용

즉, 페이지 번호와 프레임 번호를 짝지어주는 이정표

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/856e3d55-5616-432c-ba45-79970c088c99/Untitled.png)

CPU 곁에 TLB라는 페이지 테이블의 캐시 메모리 존재

(참조지역성을 근거로 최근 사용된 페이지 위주로 캐싱)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/95768d5b-0e71-4dcb-a8a0-11a0232158b3/Untitled.png)

## 페이지 교체와 프레임 할당

### 페이지 교체

메모리에 적재된 페이지 중 어떤 페이지를 내보낼지

—> 페이지 교체 알고리즘 (페이지 폴트 횟수가 적어야함)

- FIFO (First-In First-Out)
    
    메모리에 가장 먼저 올라온 페이지부터 쫓는 방식
    
- OPT (Optimal Policy)
    
    가장 낮은 페이지 폴트율을 보장하는 알고리즘
    
- LRU (Least Recently Used)
    
    가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘
    
- Clock Policy
    
    use bit를 이용하여 사용된 page는1, 사용되지 않은 page는 0으로. 0인 페이지 교체
    

- *Linux, Windows, macOS와 같은 대표적인 운영체제들은 LRU 알고리즘과 시계 알고리즘을 혼용해서 페이지 교체를 한다*

### 프레임 할당

- Fixed Partitioning
    - 균등 할당
        
        모든 프로세스에 균등하게 프레임을 할당하는 방식
        
        but, 권장 x (실행되는 프로세스마다 크기가 다르므로)
        
    - 비례 할당
        
        프레임의 크기에 비례하여 할당하는 방식
        
- Dynamic Partitioning
    - 작업 집합 모델과 페이지 폴트 빈도(Page Fault Frequency, PFF)
        
        작업 집합에 해당되면, 페이지 폴트 발생률을 측정하여 빈도가 높으면 더 많은 프레임을 할당하고, 빈도가 낮으면 프레임을 회수하는 방식
        

### 스레싱

프로세스가 실제 실행되는 시간보다 페이징에 많은 시간을 소요하여 성능이 저하되는 문제

—> 프로세스의 수가 증가하면 하나의 프로세스에 할당되는 frame수가 감소하면서 page fault를 처리하느라 발생

## 용어

### 스와핑

현재 메모리에 적재된 프로세스 중, 사용하지 않는 프로세스를 보조기억장치에 빼두고(스왑 아웃) 사용할 프로세스를 메모리로 옮겨(스왑 인) 실행하는 방식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2e1dc2d7-ab73-4426-bd42-ea5511afa0c1/c515b530-1d68-48d5-86c7-e1db8de2c5c2/Untitled.png)