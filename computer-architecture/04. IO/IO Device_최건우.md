# IO Device

목차: 

장치 컨트롤러와 장치 드라이버

다양한 입출력 방법

프로그램 입출력

---

1. 장치 컨트롤러 이야기로 시작하겠음.
2. 입출력 장치 종류는 너무 많고, 일반적으로 CPU와 메모리의 전송률을 따라가지 못함.
3. 이런 이유로, 이런 디바이스들은 장치 컨트롤러라는 하드웨어를 통해 연결하게 됨.
4. 장치 컨트롤러는 `I/O controller`, `I/O module` 등으로 불림.
5. 다음과 같은 문제들을 해결함. CPU와 입출력 장치간 통신 중개, 오류 검출, 데이터 버퍼링 등.
6. 데이터 버퍼링을 잠깐 짚고 넘어가겠음.
7. 데이터를 버퍼라는 임시 저장공간에 저장하고 한꺼번에 내보내거나, 한번에 많이 받아 조금씩 내보내는 방법이라고 생각하면 됨
    ![Untitled](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/a130989d-7cf6-48b6-b8a5-a0f3c66fa7bb)

8. 이제 내부 구조를 볼 차례인데, `data register`, `status register`, `control register` 세 가지임.
9. `data register` 에는 장치 사이에 주고 받은 데이터가 담김. 이게 버퍼 역할. (데이터가 많으면 RAM을 쓰기도 함)
10. `status register`는 입출력 준비 상태인지, 작업이 완료되었는지, 오류는 없는지 등의 상태 정보가 저장되고 `control register`는 제어 정보와 명령을 저장함.
11. 장치 컨트롤러 끝. 장치 드라이버를 얘기해보겠음.
12. 장치 드라이버는 컨트롤러의 동작을 감지하고 제어하는 프로그램이. 메모리에 저장되고, 소프트웨어적으로 통로 역할을 함.
    ![Untitled 1](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/93dc8f33-cc37-4ed2-8436-0a91b74764e2)

13. 장치 드라이버 끝.
14. 입출력 방법 세가지를 알아보겠음.
15. 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력이 있음.
16. `Programmed IO`는 명령어로 제어하는 것.
17. 단순히 생각해보면, 제어 레지스터 상태 확인 후, 명령 보내고, 상태 바뀌는거 확인하고, 저장할 데이터 버퍼로 보내면 땡임.
18. 이 방법에도 `memory-mapped IO`와 `isolated IO` 가 있음.
19. `메모리 맵 입출력`은 메모리 접근 주소공간과 입출력 장치에 접근하는 주소공간을 **하나로 간주**하는 방법임.
20. 가령, 517번지가 프린터의 상태 레지스터라면 메모리의 517를 읽는 명령으로 프린터의 상태 레지스터를 읽을 수 있음.
21. 메모리와 입출력 장치에 같은 명령어를 사용해서 통신할 수 있음.
22. `고립형 입출력`은 메모리를 위한 주소공간을 입출력 장치를 위한 주소공간과 분리하는 방법임.
23. 이 경우에는 입출력 전용 명령어를 사용해야 함.
24. programmed io 끝. 인터럽트 기반 입출력 차례임.
25. 인터럽트 기반 입출력은 디바이스가 인터럽트를 걸 때 까지 할거 하고 있는 방식임.
26. 인터럽트 요청 신호가 걸리면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행함.
27. 폴링이라는 개념과 비교되는데, 주기적으로 장치 컨트롤러의 상태 레지스터를 확인하며 입출력 장치의 상태를 확인하는 프로그램임.
28. 인터럽트가 동시에 발생하면? 이야기가 좀 필요함.
29. 먼저, 인터럽트 서비스 루틴 A를 실행하다 B가 걸리는 상황에서, 무시하고 있다가 A가 끝나면 실행하는 방법이 있음.
30. 하지만 B가 더 급하면 이대로는 안됨.
31. A 중간에 또 NMI `Non-Maskable-Interrupt` 가 걸리면 A에서 B로 넘어갔다가 다시 A로, 그 다음 프로그램으로 넘어가면 됨.
32. 우선순위를 반영하는 방법에는 PIC `Programmable Interrupt Controller` 라는 하드웨어를 사용함.
33. 여러 인터럽트 요청의 우선순위를 결정해주는 모듈.
    ![Untitled 2](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/1a92ef4c-d81f-4329-bc78-0fac6b1bb3c9)

34. 참고로, NMI는 그냥 제일 중요한거라 바로 실행함.
35. 이제 DMA 차례임.
36. 지금까진 제어가 CPU 주도이고, 무조건 데이터가 CPU를 경유한다는 공통점이 있음.
37. 하지만 CPU를 거치지 않는 방법인 DMA `Direct Memory Access` 라는 방식이 있음.
38. 시스템 버스에 DMA 컨트롤러라는 하드웨어가 필요함.
39. 순서는 대략:
(1) CPU가 DMA 컨트롤러에 작업 명령 → (2, 3) CPU 대신 장치 컨트롤러와 상호작용하며 작업 수행 → (4) DMA 컨트롤러가 CPU에 인터럽트를 걸어 작업 끝남 알림 
순임.
    ![Untitled 3](https://github.com/Ssafy-Developer-Study/CS-study/assets/39848764/25196649-cf50-472e-a939-4144f8b6d39d)
    
40. 다만, DMA 컨트롤러가 시스템 버스를 사용한다는 점이 어려움. 시스템버스는 공용 자원이기 때문.
41. CPU가 시스템 버스를 사용하지 않을 때에만 조금씩 쓰거나, CPU한테 허락을 구하고 집중적으로 쓰기도 함.
42. 이젠 입출력 버스에 대해 알아볼 차례임.
43. 이렇게 시스템 버스를 점유하는 문제를 해결하기 위해, 입출력 버스가 따로 있는 경우도 있음.
44. 대부분의 컴퓨터에는 입출력 버스가 있는데, PCI, PCIe 등의 슬롯임.
45. 최근에는 CPU의 명령 처리 몫이 많아지는 문제를 해결하기 위해 IOP `Input Output Processor` 가 탄생했음.
