# CPU 성능 향상 기법

## 1 ) 빠른 CPU를 위한 설계 기법

1. 클럭
    1. 컴퓨터 부품들은 ‘클럭 신호’에 맞게 일사불란하게 움직인다.
    2. CPU는 ‘명령어 사이클’이라는 정해진 흐름에 맞춰 명령어들을 실행한다.
    3. 클럭 속도가 높은 CPU일수록 일반적으로 성능이 좋다.
        - 클럭 속도는 CPU 속도 단위로 간주되기도 한다.
    4. 클럭 속도는 Hz 단위로 측정된다.
        1. 1초에 클럭이 몇 번 반복되었는지를 나타낸다.
        2. 만약 1초에 1번 반복되면 1Hz
        3. 만약 1초에 100번 반복되면 100Hz
    5. 클럭 속도를 무조건 높인다고 좋아지는 것은 아니다.
        1. 클럭 속도가 높은 수록 발열이 심하다.
    6. 따라서 클럭 속도만으로 CPU 성능을 올리는 것에는 한계가 있다.
2. 코어와 멀티 코어
    1. 코어
        - 명령어를 실행하는 부붐을 여러 개 포함하는 부품
    2. 멀티 코어 / 프로세서
        - 코어를 여러 개 포함하고 있는 CPU
        - 종류
            - 1 : 싱글 코어(single-core)
            - 2 : 듀얼 코어(dual-core)
            - 3 : 트리플 코어(triple-core)
            - 4 : 쿼드 코어(quad-core)
            - 6 : 헥사 코어(hexa-core)
            - 8 : 옥타 코어(octa-core)
            - 10 : 데카 코어(deca-core)
            - 12 : 도데카 코어(dodeca-core)
    3. 코어를 늘린다고 CPU의 연산 속도가 비례하여 증가하는 것은 아니다.
    4. 중요한 것은 ‘코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐’ 이다.
3. 스레드와 멀티 스레드
    1. 스레드
        - 사전적 의미
            - 실행 흐름의 단위
        - CPU에서 사용되는 스레드와 프로그래밍에서 사용되는 스레드는 서로 다르다.
            - CPU에서 사용되는 하드웨어적 스레드
            - 프로그램에서 사용되는 소프트웨어적 스레드
    2. 멀티 스레드
        - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
    3. 하드웨어적 스레드
        1. 하나의 코어가 동시에 처리하는 명령어 단위
            - 1코어 1스레드
                - 명령어를 실행하는 부품이 한 개 있고,
                한 번에 1개의 명령어를 실행
            - 2코어 4스레드
                - 명령어를 실행하는 부품이 두 개 있고,
                한 번에 4개의 명령어를 실행
            - 8코어 16스레드
                - 명령어를 실행하는 부품이 여덟 개 있고,
                한 번에 16개의 명령어를 실행
                - 코어 하나 당 두 개의 스레드를 처리한다는 의미
    4. 스프트웨어적 스레드
        1. 하나의 프로그램에서 독립적으로 실행되는 단위
        2. 하나의 프로그램이 실행되는 과정에서 한 부분만 실행될 수도 있지만,
        프로그램의 여러 부분이 동시에 실행될 수도 있다.
            - 각 기능들을 스레드로 만들면 동시에 실행할 수 있다.
    5. 멀티스레드 프로세서
        1. 핵심은 레지스터이다.
            - 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위한 레지스터를 여러 개 가지고 있으면 된다.
        2. 프로그램 입장에서는 하드웨어 스레드는 ‘한 번에 하나의 명령어를 처리하는 CPU’로 보인다.
            - 즉, 2코어 4스레드라면 CPU는 한 번에 4개의 명령어를 처리할 수 있는데, 프로그램 입장에서는 CPU가 4개 있는 것처럼 보인다.
            - 그래서 하드웨어 스레드를 논리 프로세서라고 부르기도 한다.

## 2 ) 명령어 병렬 처리 기법

1. 명령어 파이프 라이닝(Instruction pipeline / pipelining)
    1. 명령어 처리 과정
        1. 명령어 인출(Instruction Fetch)
        2. 명령어 해석(Instruction Decode)
        3. 명령어 실행(Execute Instruction)
        4. 결과 저장(Write Back)
    2. 위의 단계가 같은 시간대에 겹치지만 않는다면 CPU는 각 단계를 동시에 실행할 수 있다.
        - 효율
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/73d3b0be-c1e6-4148-b37e-69f998f896ca/Untitled.png)
            
        - 비효율
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/ede5a31c-e48f-44c7-9cd6-3ff592245ffc/Untitled.png)
            
    3. 공장 생산 라인과 같이 동시에 여러 개의 명령어를 실행시키는 것을 명령어 파이프라인 / 파이프라이닝이라고 한다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/ea815a62-7a8a-4da1-aad5-dc4f73ae9d4b/Untitled.png)
        
    4. 높은 성능을 가져오기는 하지만, 특정 상황에서 실패하는 경우가 있다. 이러한 상황을 파이프라인 위험(Pipelne hazard)이라고 부른다.
        1. 데이터 위험(data hazard)
            - 명령어 간 ‘데이터 의존성’에 의해 발생
            - 모든 명령어를 동시에 처리할 수는 없다.
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/3d878ec0-b4ae-46c4-83b5-a288a88dbadc/Untitled.png)
                
                - 다음과 같은 경우 두 번째 R1은 첫 번째 R1의 영향을 받기 때문에 1, 2는 동시에 실행될 수 없다.
        2. 제어 위험(control hazard)
            - 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생
                - 기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신된다.
                - 하지만 프로그램 실행 흐름이 바뀌어 갑작스러운 변화가 생긴다면, 미리 가지고 와서 처리 중이었떤 명령어들은 아무 쓸모가 없어진다.
                    
                    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/8ecd1f28-1e00-42d7-a6a2-fc475f0c800e/Untitled.png)
                    
            - 분기 예측(branch prediction)
                - 프로그램이 어디로 분기할지 미리 예축한 후 그 주소를 인출하는 기술로 위의 위험을 방지한다.
        3. 구조적 위험(structural hazard)
            - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 떄 발생
            - 지원 위험(resource hazard)이라고도 한다.
2. 슈퍼스칼라(Superscalar)
    1. 파이프라이닝은 단일 파이프라인으로도 구현이 가능하다.
        - 대부분의 CPU에서는 여러 개의 파이프라인을 이용한다.
    2. 여러 개의 명령어 파이프라인을  포함한 구조를 슈퍼 스칼라라고 한다.
        - 명령어 파이프라인이 공장 생산 라인을 한 개만 두는 것이라면,
        슈퍼스칼라는 공장 생산 라인을 여러 개 두는 것이다.
    3. 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 한다.
    4. 이론적으로는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만,
    실제로는 비례하지는 않는다.
        - 하나의 파이프라인이 아니기 때문에 위험성도 그만큼 증가한다.
        - 따라서 고도의 설계가 필요하다.
3. 비순차적 명령어 처리(Out-of-order execution, OoOE)
    1. CPU 성능 향상에 크게 기여한 기법이자, 대부분의 CPU가 차용하는 기법
    2. 명령어 파이프라이닝, 슈퍼스칼라 기법은 모두 여러 명령어의 순차적인 처리를 상정한 방법
        - 하지만 예상치 못한 문제들로 명령어가 처리되지 못하고 멈추는 경우가 발생
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/260983f2-7796-4c9c-8c5e-ef5d7b20d47e/Untitled.png)
            
    3. 위의 상황을 방지하고자 명령어를 순차적으로 실행하지 않고 순서를 바꿔도 무방한 명령어를 먼저 실행하는 것을 비순차적 명령어 처리 기법이라고 한다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/e1553381-302f-490e-8867-a2843f66a251/Untitled.png)
        

## 3 ) CISC와 RISC

1. 명령어 집합
    1. CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합(Instruction set) 또는 명령어 집합 구조(Instruction Set Architecture, ISA)라고 한다.
        - CPU, 즉 제조사마다 ISA가 다를 수 있다.
        - 인텔 : x86-64
        - 애플 : ARM
            - 서로의 명령어를 이해하지 못한다.
    2. ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻이고, 명령어가 달라지면 어셈블리어도 달라진다.
        - 같은 소스 코드여도 ISA가 다르면, 어셈블리어도 달라진다.
2. CISC(Complex Instruction Set Computer)
    1. ‘복잡한 명령어 집합을 활용하는 컴퓨터’를 의미
        - 다양한 명령어들을 활용하는 CPU 설계 방식
    2. 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용한다.
    3. 다양하고 강력한 명령어를 활용한다는 말은 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 뜻
        - 명령어의 수가 적다는 말은 ‘컴파일된 프로그램의 크기가 작다’는 것을 의미한다.
    4. 장점
        - 메모리 공간을 절약할 수 있다는 장점이 있다.
    5. 단점
        - 명령어가 복잡하고 다양하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않다.
        - 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다.
            - 이는 명령어 파이프라인을 구현하는 데에 큰 컬림돌이 된다.
        - 규격화되지 않은 명령어가 파이프라이닝을 어렵게 만든다.
3. RISC(Reduced Instruction Set Computer)
    1. 다음을 고려해야 한다.
        1. 원할한 파이프라이닝을 위해 ‘명령어 길이과 수행 시간이 짧고 규격화’되어 있어야 한다.
        2. 복잡한 기능을 지원하는 명령어를 추가하기보다 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것이 중요하다.
    2. RISC는 CISC와 달리 짧고 규격화된 명령어를 지원하고, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.
        - 즉, RISC는 고정 길이 명령어를 활용한다.
    3. 따라서 RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있다.
    4. 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할만큼 메모리 접근을 단순화하고 최소화하였다.
        - 대신 레지스터를 적극적으로 활용한다.
    5. CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.
4. CISC / RISC 비교
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ccd9570b-85c2-4c37-a7ea-3521eb1cd311/244689c6-2aff-4dc9-b10f-b4537991f4fb/Untitled.png)
